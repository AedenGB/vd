function [y_new, forces, nextFz] = calcAngles2(car,x,y0,forces,xdot0)

n = round(car.TSmpc/car.TSdyn,0);
dt = car.TSdyn;
y = y0;

cArr = car.c*ones(1,4); %intialize damp coeff array for all tires
MRArr = ones(1,4); %intialize MR array for all tires

% tires 3 and 4 switched from jazar model
for i = 2:n+1  
    for i=1:2 %calculate motion ratios by interp of data
        tireX = y(i+3)*39.3701; %get current tire pos (m to in)
        MRArr(i) = lininterp1(car.MR_F(:,1),car.MR_R(:,2),tireX); %MR data within damping mat
    end
    for i=3:4 %calculate motion ratios by interp of data
        tireX = y(i+3)*39.3701; %get current tire pos (m to in)
        MRArr(i) = lininterp1(car.MR_F(:,1),car.MR_R(:,2),tireX); %MR data within damping mat
    end
    
    x_vec = [0 0.5 7 10];
    c_vec = [0 20 40 50];
    
    for i =1:4 %calculate damping coeff by interp of dampincurves.mat data
        v(i) = y(i+10)*MRArr(i)*39.3701; %get current tire vel (m/s to in/s)
        
        if v(i) == 0
            cArr(i) = 0;
        elseif v(i) > 0
            cArr(i) = lininterp1(x_vec,c_vec,v(i))/v(i)*175.126835;
        else
            cArr(i) = lininterp1(x_vec,c_vec,-v(i))/v(i)*-175.126835;
        end
    end
    
    k_tf = car.k*10;
    k_tr = k_tf;
    m = car.M;
    m_f = m/10;
    m_r = m_f;
    k_rf = car.k_rf;
    k_rr = car.k_rr;
    Ix = car.Ixx;
    Iy = car.Iyy;
    a_1 = car.l_f;
    a_2 = car.l_r;
    b_1 = car.t_f/2;
    b_2 = car.t_f/2;
    w = car.t_f;
    
    k_1 = car.k*MRArr(1)^2; %tire k = spring k * MR^2
    k_2 = car.k*MRArr(2)^2;
    k_3 = car.k*MRArr(3)^2;
    k_4 = car.k*MRArr(4)^2;    
    c_1 = cArr(1);
    c_2 = cArr(2);
    c_3 = cArr(3);
    c_4 = cArr(4);
        
    m = diag([m Ix Iy m_f m_f m_r m_r]);
    
    c11 = c_1+c_2+c_3+c_4;
    c21 = b_1*c_1-b_2*c_2+b_1*c_3-b_2*c_4; 
    c12 = c21;
    c31 = a_2*(c_3+c_4)-a_1*(c_1+c_2);
    c13 = c31;
    c22 = b_1^2*c_1+b_2^2*c_2+b_1^2*c_3+b_2^2*c_4; 
    c32 = a_1*b_2*c_2-a_1*b_1*c_1+a_2*b_1*c_3-a_2*b_2*c_4; 
    c23 = c32;
    c33 = (c_1+c_2)*a_1^2+(c_4+c_3)*a_2^2; 
    
    c = [c11 c12 c13 -c_1 -c_2 -c_3 -c_4;
        c21 c22 c23 -b_1*c_1 b_2*c_2 -b_1*c_3 b_2*c_4;
        c31 c32 c33 a_1*c_1 a_1*c_2 -a_2*c_3 -a_2*c_4;
        -c_1 -b_1*c_1 a_1*c_1 c_1 0 0 0;
        -c_2 b_2*c_2 a_1*c_2 0 c_2 0 0;
        -c_3 -b_1*c_3 -a_2*c_3 0 0 c_3 0;
        -c_4 b_2*c_4 -a_2*c_4 0 0 0 c_4];
    
    k11 = k_1+k_2+k_3+k_4;
    k21 = b_1*k_1-b_2*k_2+b_1*k_3-b_2*k_4;
    k12 = k21;
    k31 = a_2*(k_3+k_4)-a_1*(k_1+k_2);
    k13 = k31;
    k22 = k_rf+k_rr+b_1^2*k_1+b_2^2*k_2+b_1^2*k_3+b_2^2*k_4;
    k32 = a_1*b_2*k_1-a_1*b_2*k_2+a_2*b_1*k_3-a_2*b_2*k_4;
    k23 = k32;
    
    k42 = -b_1*k_1-k_rf/w;
    k24 = k42;
    k52 = b_2*k_2+k_rf/w;
    k25 = k52;
    
    k62 = -b_1*k_3-k_rr/w;
    k26 = k62;
    k72 = b_2*k_4+k_rr/w;
    k27 = k72;
    
    k33 = (k_1+k_2)*a_1^2+(k_1+k_2)*a_2^2;
    k44 = k_1+k_tf+k_rf/w^2;
    k55 = k_2+k_tf+k_rf/w^2;
    
    k = [k11 k12 k13 -k_1 -k_2 -k_3 -k_4;
        k21 k22 k23 k24 k25 k26 k27;
        k31 k32 k33 a_1*k_1 a_1*k_2 -a_2*k_3 -a_2*k_4;
        -k_1 k42 a_1*k_1 k44 -k_rf/w^2 0 0;
        -k_2 k52 a_1*k_2 -k_rf/w^2 k55 0 0;
        -k_3 k62 -a_2*k_3 0 0 k_3+k_tr 0;
        -k_4 k72 -a_2*k_4 0 0 0 k_4+k_tr];
    
    tireForceXY = forces.Ftires;
    tireForceXY(:,3) = 0;
    yawRate = x(2);
    longVel = x(3);
    latVel = x(4);
    
    lat_accel = longVel.*yawRate+xdot0(4,:);
    long_accel = -latVel.*yawRate+xdot0(3,:);
    rollMoment = -car.M*lat_accel*(car.h_g-car.h_rc);
    pitchMoment = -car.M*long_accel*(car.h_g-car.h_rc);
        
    jacking_rotation = [1 1 1 1; b_1 -b_2 b_1 -b_2; -a_1 -a_1 a_2 a_2];
    jacking_Fz = [car.h_rf/b_1; -car.h_rf/b_2; car.h_rr/b_1; -car.h_rr/b_2].*tireForceXY(:,2);
    % jacking_vec: [vertical force; roll moment; pitch moment]
    % ISO convention
    jacking_vec = jacking_rotation*jacking_Fz;
    
    %add up all applied moments, using given position vectors
    sumM = 0;
    for i = 1:size(forces.F,1)
        sumM = sumM+cross(forces.F(i,4:6),forces.F(i,1:3)); 
    end
    rollMoment = rollMoment+sumM(1);
    pitchMoment = pitchMoment-sumM(2);
    
    % transform from SAE coordinate system to ISO
    % [applied sprung mass vertical force, roll moment, pitch moment,
    % unsprung mass forces]
    F = [-sum(forces.F(:,3)) rollMoment pitchMoment 0 0 0 0]';
    F = F + [jacking_vec; jacking_Fz];

    % state vector: [x phi theta x1 x2 x3 x4]'
    yd = [y(8:end); m\(F-c*y(8:end)-k*y(1:7))];
    
    nextFz = -diag([k_tf k_tf k_tr k_tr])*y(4:7);
    y = y+yd*car.TSdyn;
end

y_new = y;

end